//Eloquent JavaScript

//Name:FizzBuzz

//Exercise:
// Напишите программу, в которой с помощью console. log выводятся все числа от 1 до 100 с двумя исключениями. Для чисел, кратных 3, вместо числа
// выводится "Fizz", а для чисел, кратных 5 (но не 3), - "Buzz".
// 58 Глава 2. Структура программы
// Когда это заработает, измените программу так, чтобы она печатала "FizzBuzz"
// для чисел, которые делятся и на 3, и на 5 (и по-прежнему печатайте "Fizz"
// или "Buzz" для чисел, кратных только одному из них).
// На самом деле такой вопрос задают на собеседованиях и, по утверждениям,
//     отсеивают на нем значительную долю кандидатов в программисты. Поэтому
// если вы решили эту задачу, то стоимость вашего труда резко возросла.

//Solution:
function FizzBuzz(){
    for(let i=1;i<=100;i++){
        if(i%3==0&&i%5==0)
            console.log("FizzBuzz")
        else
        if(i%3==0)
            console.log("Fizz")
        else
        if(i%5==0)
            console.log("Buzz")
        else
            console.log(i);
    }
}
FizzBuzz();

//Name:Chessboard

//Exercise:
// Напишите программу, которая создает строку, представляющую сетку 8 х 8,
// используя для разделения строк символы новой строки. В каждой позиции
// сетки стоит либо пробел, либо символ"#". Эти символы должны располагаться в шахматном порядке.
//Если вы уже написали программу, которая генерирует этот узор, определите
// привязку size = 8 и измените программу так, чтобы она работала для любого
// size, выводя сетку заданных ширины и высоты.

//Solution:

let board = "";
function chessboard(size){
    for (let y=0;y<size;y++) {
        for (let x=0;x<size;x++) {
            if ((x + y) % 2 == 0) {
                board +=" ";
            } else {
                board +="#";
            }
        }
        board +="\n";
    }
}
chessboard(prompt("What's about size?"))
console.log(board)

//Name:Minimum

//Exercise:
// В предыдущей главе была представлена стандартная функция Math. min,
// которая возвращает наименьший из ее аргументов. Теперь мы можем сами
// создать нечто подобное. Напишите функцию min, которая принимает два
// аргумента и возвращает их минимум.

//Solution:
const min=(a,b)=>{
    if(a<b) return a;
    else
        return b;
}
console.log(min(0, 10));
// → 0
console.log(min(0, -10));
// → -10

//Name:Recursion

//Exercise:
// Как мы видели, оператор% (оператор остатка) можно применять для проверки, является число четным или нечетным. Для этого нужно использовать
// %2, чтобы узнать, делится ли оно на два. Вот еще один способ определить,
// является ли положительное целое число четным или нечетным:
// D ноль четный;
// D единица нечетная;
// D четность любого другого числа N совпадает с четностью N - 2.
// Определите рекурсивную функцию isEven, соответствующую этому описанию. Функция должна принимать один параметр (положительное целое
// число) и возвращать логическое значение.
// Проверьте эту функцию на числах 50 и 75. Посмотрите, как она ведет себя
// для -1. Почему? Можете ли вы придумать способ, как это

//Solution:

const isEven=(num) =>
{
    if(num==1) return false;
    if(num==2) return true;
    if(num==-1) return false;
    return isEven(num-2);
}

console.log(isEven(50));
// → true
console.log(isEven(75));
// → false
console.log(isEven(-1));
// → false
//Name:Подсчет букв

//Exercise:
// Чтобы получить N-й символ или букву из строки, нужно написать "string" [N].
// Возвращаемым значением будет строка, содержащая только один символ
// (например, "Ь"). Первый символ имеет позицию О, в результате чего последний находится в позиции string. length - 1. Другими словами, длина
// строки из двух символов равна 2, а ее символы находятся в позициях О и 1.
// Напишите функцию countBs, которая принимает строку в качестве единственного аргумента и возвращает число, показывающее, сколько больших
// букв ~в~ содержится в этой строке.
// Затем напишите функцию countChar, которая ведет себя как countBs, за исключением того, что принимает второй аргумент, указывающий, какие именно символы нужно посчитать (вместо того чтобы считать только большие
// буквы ~в~). Перепишите countBs, чтобы использовать эту новую функцию.

//Solution:
const countChar=(str,ch)=>{
    let counter = 0;
    for(let i=0;i<str.length;i++){
        if(str.charAt(i)==ch)
            counter++;
    }
    return counter;
}

console.log(countChar("BBC","B"));
// → 2
console.log(countChar("kakkerlak", "k"));
// → 4

//Name:The sum of range

//Exercise:Во введении к этой книге упоминался следующий хороший способ вычислить сумму диапазона чисел:
// console.log(sum(range(l, 10)));
// Напишите функцию range, которая принимает два аргумента, start и end,
// и возвращает массив, содержащий все числа от start до end включительно.
// Затем напишите функцию sum, которая принимает массив чисел и возвращает их сумму. Запустите пример программы и посмотрите, действительно
// ли она возвращает 55.
// В качестве дополнительного задания: измените функцию range так, чтобы
// она принимала необязательный третий аргумент, который указывал бы
// значение шага, используемое при построении массива. Если шаг не задан,
// элементы увеличиваются на единицу, что соответствует старому поведению.
// Вызов функции range(l, 10, 2) должен возвращать [1, з, 5, 7, 9). Убедитесь,
// что функция также работает и с отрицательными значениями шага, так что
// результатом range(5, 2, -1) является [5, 4, з, 2).

//Solution:
const range=(start,end,step=1)=>{
    let array=[];
    if(start<end){
        for(let counter=start;counter<=end;counter+=step){
            array.push(counter);
        }
    }
    if(start>end){
        for(let counter=start;counter>=end;counter+=step){
            array.push(counter);
        }
    }
    return array;
}

const sum=(array)=> {
    let total = 0;
    for (let i=0;i<array.length;i++) {
        total += array[i];
    }
    return total;
}

console.log(range(1, 10))
// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(range(5, 2, -1));
// → [5, 4, 3, 2]
console.log(sum(range(1, 10)));
// → 55

//Name:reverse array

//Exercise:У массивов есть метод reverse, который изменяет порядок следования
// элементов в массиве. Для выполнения этого упражнения напишите две
// 104 Глава 4. СТруктуры данных: объекты и массивы
// функции: reverseArray и reverseArrayinPlace. Первая функция, reverseArray,
// принимает массив в качестве аргумента и создает новый массив, содержащий
// те же элементы в обратном порядке. Вторая, reverseArrayinPlace, делает
// то же, что и метод reverse: преобразовывает массив, заданный в качестве
// аргумента, меняя порядок следования его элементов на обратный. Не используйте для этого стандартный метод reverse.


//Solution:
function reverseArray(array) {
    let newarr=[];
    for (let i = array.length-1; i >0;i--) {
        newarr.push(array[i]);
    }
    return newarr;
}

function reverseArrayInPlace(array) {
    for (let i=0; i<Math.floor(array.length/2); i++) {
        let old = array[i];
        array[i] = array[array.length-1-i];
        array[array.length-1-i]=old;
    }
    return array;
}

console.log(reverseArray(["A", "B", "C"]));
// → ["C", "B", "A"];
let arrayValue = [1, 2, 3, 4, 5];
reverseArrayInPlace(arrayValue);
console.log(arrayValue);
// → [5, 4, 3, 2, 1]

//Name:Свертка

//Exercise:
// Используйте метод reduce в сочетании с методом concat для свертки массива, состоящего из нескольких массивов, в один массив, у которого есть
// все элементы входных массивов.


//Solution:
let arrays = [[1, 2, 3], [4, 5], [6]];
console.log(arrays.reduce((array,current)=>array.concat(current), []));
// → [1, 2, 3, 4, 5, 6]

//Name:Метод every

//Exercise:
// Для массивов существует метод every, аналогичный методу some. Этот метод возвращает true, когда заданная функция возвращает true для каждого
// элемента массива. В некотором смысле some - это версия оператора 11 для
// массивов, а метод every подобен оператору &&.
// Реализуйте метод every, принимающий в качестве параметров массив и предикативную функцию. Напишите две версии: одну с использованием цикла,
// а вторую - с применением метода some.

//Solution:
function every(array, test) {
    for(let current=0;current<array.length;current++){
        if(!test(array[current]))
            return false
    }
    return true
}
console.log(every([1, 3, 5], n => n < 10));
// → true
console.log(every([2, 4, 16], n => n < 10));
// → false
console.log(every([], n => n < 10));
// → true


//Name:
// Тип вектора

//Exercise:
// Напишите класс Vec, который представляет вектор в двумерном пространстве. Вектор принимает параметры х и у (числа) и сохраняет их в свойствах
// с тем же именем.
// 142 Глава 6. Тайная жизнь объектов
// Напишите для прототипа Vec два метода, plus и minus, которые принимают
// в качестве параметра другой вектор и возвращают новый вектор, представляющий собой сумму или разность значений х и у для двух векторов (this
// и параметра).
// Добавьте в прототип свойство-геттер length, которое вычисляет длину
// вектора - расстояние от точки (х, у) до начала координат (О, О).

//Solution:
class Vec {
    constructor(x, y) {
        this.x= x;
        this.y= y;
    }

    plus(other) {
        return new Vec(this.x + other.x,this.y + other.y);
    }

    minus(other) {
        return new Vec(this.x - other.x,this.y - other.y);
    }

    get length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
}
console.log(new Vec(1, 2).plus(new Vec(2, 3)));
// → Vec{x: 3, y: 5}
console.log(new Vec(1, 2).minus(new Vec(2, 3)));
// → Vec{x: -1, y: -1}
console.log(new Vec(3, 4).length);
// → 5

//К сожалению я плохо себя чувствую мегодня и понял,что не все изученное в этой главе полностью понято мной.Я
// вернусь к ней завтра и дополню этот файл решениями задач.Также решу задачи из следующеё главы.
// Возвращайтесь завтра
//Name:

//Exercise:

//Solution:
